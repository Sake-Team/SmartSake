<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Sake Table - Dashboard</title>
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<link rel="stylesheet" href="styles.css">
</head>

<body>
	<div class="page-wrapper">

		<header class="header">
			<div class="header-inner">
				<img src="images/VoidSakeLogo.jpg" alt="Smart Sake logo" id="sake-logo-egg" class="sake-logo-egg" />

				<h1 class="header-title">
					Home <span id="run-name-display" class="run-name-header"></span>
				</h1>
			</div>

			<div class="header-meta">
				<div class="header-start-btn-wrap">
				</div>
			</div>

		</header>

		<main>
			<div class="stage">
				<section class="layout">
					<section class="zones">
						<a class="zone" href="zone1.html" role="button" aria-label="Zone 1">Zone 1</a>
						<a class="zone" href="zone2.html" role="button" aria-label="Zone 2">Zone 2</a>
						<a class="zone" href="zone3.html" role="button" aria-label="Zone 3">Zone 3</a>
						<a class="zone" href="zone4.html" role="button" aria-label="Zone 4">Zone 4</a>
						<a class="zone" href="zone5.html" role="button" aria-label="Zone 5">Zone 5</a>
						<a class="zone" href="zone6.html" role="button" aria-label="Zone 6">Zone 6</a>
					</section>

					<div class="notes-wrap">
						<div class="notes__meta" id="notes-meta" aria-live="polite">Date,
							Time</div>
						<div class="notes" aria-label="Notes">
							<label class="sr-only" for="notes-input">Notes</label>
							<textarea id="notes-input" class="notes__input" placeholder="Enter notes..."
								aria-label="Notes input"></textarea>
						</div>
					</div>

					<div class="left">
						<div class="long long--top-left">
							<div class="chart-header">
								<span>Temperature over time</span>
								<button type="button" class="temp-overlay-btn" id="start-run-btn">Start Run</button>
							</div>
							<canvas id="temp-chart"></canvas>
						</div>

						<div class="long long--top-left">
							<span>Humidity over time</span>
							<canvas id="humidity-chart"></canvas>
						</div>

						<div class="long long--top-left">Fans on/off over time</div>
					</div>

				</section>

				<section class="temp-row" aria-label="Temperature readings">
					<div class="temp">
						<span class="temp__label">Temp 1</span>
						<span class="temp__value"><span class="temp__num" id="temp-1">--</span><span
								class="temp__unit">Â°F</span></span>
					</div>
					<div class="temp">
						<span class="temp__label">Temp 2</span>
						<span class="temp__value"><span class="temp__num" id="temp-2">--</span><span
								class="temp__unit">Â°F</span></span>
					</div>
					<div class="temp">
						<span class="temp__label">Temp 3</span>
						<span class="temp__value"><span class="temp__num" id="temp-3">--</span><span
								class="temp__unit">Â°F</span></span>
					</div>
					<div class="temp">
						<span class="temp__label">Temp 4</span>
						<span class="temp__value"><span class="temp__num" id="temp-4">--</span><span
								class="temp__unit">Â°F</span></span>
					</div>
					<div class="temp">
						<span class="temp__label">Temp 5</span>
						<span class="temp__value"><span class="temp__num" id="temp-5">--</span><span
								class="temp__unit">Â°F</span></span>
					</div>
					<div class="temp">
						<span class="temp__label">Temp 6</span>
						<span class="temp__value"><span class="temp__num" id="temp-6">--</span><span
								class="temp__unit">Â°F</span></span>
					</div>
				</section>
			</div>
		</main>

		<!-- Modal popup for Start run -->
		<div id="start-run-modal" class="modal-overlay">
			<div class="modal-popup">
				<div class="modal-header">
					<h3 class="modal-title">Start New Run</h3>
					<button type="button" class="modal-close" id="close-modal" aria-label="Close modal">&times;</button>
				</div>
				<div class="modal-content">
					<p>This will begin collecting data from all temperature sensors and
						start the monitoring process.</p>

					<div class="modal-input-section">
						<label for="run-name">Run Name:</label>
						<input type="text" id="run-name" name="run-name" placeholder="Enter run name..." />
					</div>

					<div class="modal-input-section">
						<label for="target-csv-upload">Select Koji Strain:</label>
						<input type="file" id="target-csv-upload" accept=".csv" class="upload-input">
						<div id="upload-status" class="upload-status"></div>
						<small class="help-text">Upload a CSV with target temperatures over
							time</small>
					</div>

					<div class="modal-input-section">
						<button type="button" class="modal-enter-btn" id="enter-run-btn">Start</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Modal popup for End run confirmation -->
		<div id="end-run-modal" class="modal-overlay">
			<div class="modal-popup">
				<div class="modal-header">
					<h3 class="modal-title">End Current Run</h3>
					<button type="button" class="modal-close" id="close-end-modal"
						aria-label="Close modal">&times;</button>
				</div>
				<div class="modal-content">
					<p>Are you sure you would like to end the run?</p>
					<p>This will stop data collection and finalize the current monitoring
						session.</p>

					<div class="modal-button-section">
						<button type="button" class="modal-cancel-btn" id="cancel-end-btn">Cancel</button>
						<button type="button" class="modal-confirm-btn" id="confirm-end-btn">End Run</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Recovery popup for crashed / unfinished runs -->
		<div id="recovery-modal" class="modal-overlay">
			<div class="modal-popup">
				<div class="modal-header">
					<h3 class="modal-title">Recovered Run Detected</h3>
					<button type="button" class="modal-close" id="recovery-close-btn"
						aria-label="Close recovery popup">&times;</button>
				</div>
				<div class="modal-content">
					<p>We detected autosaved data from a previous session that didn't end
						cleanly.</p>
					<p>You can export the recovered run as a CSV or discard it and start
						fresh.</p>

					<div class="modal-button-section">
						<button type="button" class="modal-cancel-btn" id="recovery-discard-btn">Discard</button>
						<button type="button" class="modal-confirm-btn" id="recovery-export-btn">Export recovered
							CSV</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Easter egg Pong modal -->
		<div id="pong-modal" class="modal-overlay">
			<div class="modal-popup pong-modal-popup">
				<div class="modal-header">
					<h3 class="modal-title">Pong Mode</h3>
					<button type="button" class="modal-close" id="pong-close-btn"
						aria-label="Close Pong">&times;</button>
				</div>
				<div class="modal-content">
					<canvas id="pong-canvas" width="500" height="300" aria-label="Pong game"></canvas>
					<p class="pong-help-text">
						Use â†‘ and â†“ arrows to move your paddle. Press ESC to exit.
					</p>
				</div>
			</div>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

		<!-- Live Date/Time script: updates the .notes__meta element each minute -->
		<script>
			// Live Date/Time script: updates notes meta and header datetime each minute
			(function () {
				const notesMeta = document.getElementById('notes-meta');
				const headerMeta = document.getElementById('header-datetime');

				if (!notesMeta && !headerMeta) return;

				function formatNow(d) {
					const date = d.toLocaleDateString(undefined, {
						month: 'short',
						day: 'numeric',
						year: 'numeric'
					});
					const time = d.toLocaleTimeString(undefined, {
						hour: '2-digit',
						minute: '2-digit'
					});
					return `${date} â€” ${time}`;
				}

				function update() {
					const text = formatNow(new Date());
					if (notesMeta) notesMeta.textContent = text;
					if (headerMeta) headerMeta.textContent = text;
				}

				// initial update
				update();

				// align with start of next minute, then every 60s
				const msToNext = 60000 - (Date.now() % 60000);
				let timer = setTimeout(function () {
					update();
					timer = setInterval(update, 60000);
				}, msToNext);

				// update when user returns to tab
				document.addEventListener('visibilitychange', function () {
					if (document.visibilityState === 'visible') update();
				});
			})();


			// Modal + run state + autosave + recovery
			(function () {
				const RUN_STATE_KEY = 'sakeRunState';
				const RUN_IN_PROGRESS_KEY = 'sakeRunInProgress';

				// DOM elements
				const startBtn = document.getElementById('start-run-btn');
				const startModal = document.getElementById('start-run-modal');
				const closeStartBtn = document.getElementById('close-modal');
				const enterBtn = document.getElementById('enter-run-btn');
				const runNameInput = document.getElementById('run-name');
				const runNameDisplay = document.getElementById('run-name-display');

				const endModal = document.getElementById('end-run-modal');
				const closeEndBtn = document.getElementById('close-end-modal');
				const cancelEndBtn = document.getElementById('cancel-end-btn');
				const confirmEndBtn = document.getElementById('confirm-end-btn');

				const recoveryModal = document.getElementById('recovery-modal');
				const recoveryExport = document.getElementById('recovery-export-btn');
				const recoveryDiscard = document.getElementById('recovery-discard-btn');
				const recoveryClose = document.getElementById('recovery-close-btn');

				let collectedData = [];
				let dataCollectionInterval = null;
				let runStartTime = null;

				// ---------- Autosave helpers ----------
				function saveRunState() {
					try {
						const state = {
							collectedData,
							runStartTime: runStartTime ? runStartTime.toISOString() : null,
							runName: localStorage.getItem('currentRunName') || null
						};
						localStorage.setItem(RUN_STATE_KEY, JSON.stringify(state));
					} catch (e) {
						console.warn('Autosave failed:', e);
					}
				}

				function loadRunState() {
					try {
						const raw = localStorage.getItem(RUN_STATE_KEY);
						if (!raw) return;

						const state = JSON.parse(raw);
						if (Array.isArray(state.collectedData)) {
							collectedData = state.collectedData;
						}
						if (state.runStartTime) {
							runStartTime = new Date(state.runStartTime);
						}
						console.log('Recovered autosaved run:', collectedData.length, 'rows restored');
					} catch (e) {
						console.warn('Failed to load autosaved run:', e);
						localStorage.removeItem(RUN_STATE_KEY);
					}
				}

				// ---------- Data generation ----------
				function generateSensorData() {
					const timestamp = new Date().toISOString();
					const temps = [];

					const csvTemps = window.getCurrentTemperatures ? window.getCurrentTemperatures() : null;

					for (let i = 1; i <= 6; i++) {
						if (csvTemps && csvTemps[`temp${i}`] && csvTemps[`temp${i}`] !== '--') {
							temps.push(csvTemps[`temp${i}`]);
						} else {
							const tempElement = document.getElementById(`temp-${i}`);
							if (tempElement && tempElement.textContent !== '--') {
								temps.push(tempElement.textContent);
							} else {
								temps.push((70 + Math.random() * 10).toFixed(1));
							}
						}
					}

					const humidity = (60 + Math.random() * 20).toFixed(1);
					const fans = [];
					for (let i = 1; i <= 6; i++) {
						fans.push(Math.random() > 0.5 ? 'On' : 'Off');
					}
					const notes = localStorage.getItem('currentNotes') || '';

					return {
						timestamp,
						temp1: temps[0],
						temp2: temps[1],
						temp3: temps[2],
						temp4: temps[3],
						temp5: temps[4],
						temp6: temps[5],
						humidity,
						fan1: fans[0],
						fan2: fans[1],
						fan3: fans[2],
						fan4: fans[3],
						fan5: fans[4],
						fan6: fans[5],
						notes: notes.replace(/[\r\n]/g, ' ')
					};
				}

				// ---------- Start / stop collection ----------
				function startDataCollection() {
					collectedData = [];
					runStartTime = new Date();

					localStorage.setItem(RUN_IN_PROGRESS_KEY, 'true');

					collectedData.push(generateSensorData());
					saveRunState();

					dataCollectionInterval = setInterval(function () {
						collectedData.push(generateSensorData());
						saveRunState();
					}, 30000);
				}

				function stopDataCollectionAndExport(runName) {
					if (dataCollectionInterval) {
						clearInterval(dataCollectionInterval);
						dataCollectionInterval = null;
					}

					if (collectedData.length > 0) {
						collectedData.push(generateSensorData());
					}

					let csvContent = 'Timestamp,Temp1,Temp2,Temp3,Temp4,Temp5,Temp6,Humidity,' +
						'Fan1,Fan2,Fan3,Fan4,Fan5,Fan6,Notes\n';

					collectedData.forEach(function (data) {
						csvContent += `${data.timestamp},${data.temp1},${data.temp2},${data.temp3},${data.temp4},` +
							`${data.temp5},${data.temp6},${data.humidity},${data.fan1},${data.fan2},` +
							`${data.fan3},${data.fan4},${data.fan5},${data.fan6},"${data.notes}"\n`;
					});

					const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
					const link = document.createElement('a');
					if (link.download !== undefined) {
						const url = URL.createObjectURL(blob);
						link.setAttribute('href', url);
						link.setAttribute('download', `${runName}.csv`);
						link.style.visibility = 'hidden';
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
					}

					collectedData = [];
					localStorage.removeItem(RUN_STATE_KEY);
					localStorage.setItem(RUN_IN_PROGRESS_KEY, 'false');

					const notesInput = document.getElementById('notes-input');
					if (notesInput) {
						notesInput.value = '';
						localStorage.removeItem('currentNotes');
					}
				}

				// Expose for recovery export
				window.sakeExportRecoveredRun = function () {
					const currentRunName = localStorage.getItem('currentRunName') || 'RecoveredRun';

					if (recoveryModal) {
						recoveryModal.style.display = 'none';
					}

					stopDataCollectionAndExport(currentRunName);

					if (window.stopTemperatureReading) {
						window.stopTemperatureReading();
					}
					if (window.clearRunData) {
						window.clearRunData();
					}
					localStorage.removeItem('currentNotes');

					if (runNameDisplay) {
						runNameDisplay.textContent = '';
					}
					localStorage.removeItem('currentRunName');

					if (startBtn) {
						startBtn.textContent = 'Start Run';
						startBtn.classList.remove('end-run-btn-active');
						startBtn.style.pointerEvents = 'auto';
						startBtn.style.cursor = 'pointer';
					}
				};

				// ---------- Load autosave & handle crash detection ----------
				loadRunState();
				const savedRunName = localStorage.getItem('currentRunName');
				const rawState = localStorage.getItem(RUN_STATE_KEY);
				const inProgress = localStorage.getItem(RUN_IN_PROGRESS_KEY) === 'true';

				let hasData = false;
				if (rawState) {
					try {
						const state = JSON.parse(rawState);
						if (state && Array.isArray(state.collectedData) && state.collectedData.length > 0) {
							hasData = true;
						}
					} catch (e) {
						console.warn('Invalid autosave state detected, clearing:', e);
						localStorage.removeItem(RUN_STATE_KEY);
					}
				}

				const crashDetected = hasData && inProgress;

				// Initialize UI state
				if (runNameDisplay) {
					runNameDisplay.textContent = crashDetected && savedRunName ? ('- ' + savedRunName) : '';
				}
				if (startBtn) {
					startBtn.textContent = 'Start Run';
					startBtn.classList.remove('end-run-btn-active');
					startBtn.style.pointerEvents = 'auto';
					startBtn.style.cursor = 'pointer';
				}

				if (crashDetected && recoveryModal && recoveryExport && recoveryDiscard) {
					recoveryModal.style.display = 'flex';

					recoveryExport.addEventListener('click', function () {
						if (window.sakeExportRecoveredRun) {
							window.sakeExportRecoveredRun();
						}
						localStorage.setItem(RUN_IN_PROGRESS_KEY, 'false');
						if (recoveryModal) recoveryModal.style.display = 'none';
					});

					recoveryDiscard.addEventListener('click', function () {
						localStorage.removeItem(RUN_STATE_KEY);
						localStorage.setItem(RUN_IN_PROGRESS_KEY, 'false');
						localStorage.removeItem('currentRunName');
						if (runNameDisplay) runNameDisplay.textContent = '';
						if (recoveryModal) recoveryModal.style.display = 'none';
					});

					if (recoveryClose) {
						recoveryClose.addEventListener('click', function () {
							localStorage.removeItem(RUN_STATE_KEY);
							localStorage.setItem(RUN_IN_PROGRESS_KEY, 'false');
							localStorage.removeItem('currentRunName');
							if (runNameDisplay) runNameDisplay.textContent = '';
							if (recoveryModal) recoveryModal.style.display = 'none';
						});
					}

					document.addEventListener('keydown', function (e) {
						if (e.key === 'Escape' && recoveryModal.style.display === 'flex') {
							localStorage.removeItem(RUN_STATE_KEY);
							localStorage.setItem(RUN_IN_PROGRESS_KEY, 'false');
							localStorage.removeItem('currentRunName');
							if (runNameDisplay) runNameDisplay.textContent = '';
							recoveryModal.style.display = 'none';
						}
					});
				} else {
					// no crash: normalize flags if no saved name
					if (!savedRunName) {
						localStorage.removeItem(RUN_STATE_KEY);
						localStorage.setItem(RUN_IN_PROGRESS_KEY, 'false');
					}
				}

				// ---------- Guard: if core elements are missing, stop here ----------
				if (!startBtn || !startModal || !closeStartBtn || !enterBtn || !runNameInput) {
					return;
				}

				// ---------- Start button (open start modal or end modal) ----------
				startBtn.addEventListener('click', function () {
					if (startBtn.classList.contains('end-run-btn-active')) {
						if (endModal) endModal.style.display = 'flex';
					} else {
						const fileInput = document.getElementById('target-csv-upload');
						const uploadStatus = document.getElementById('upload-status');
						if (fileInput) fileInput.value = '';
						if (uploadStatus) uploadStatus.textContent = '';

						if (window.setupFileUploadHandler) {
							window.setupFileUploadHandler();
						}

						startModal.style.display = 'flex';
						runNameInput.focus();
					}
				});

				// ---------- Start modal close ----------
				closeStartBtn.addEventListener('click', function () {
					startModal.style.display = 'none';
				});

				startModal.addEventListener('click', function (e) {
					if (e.target === startModal) {
						startModal.style.display = 'none';
					}
				});

				document.addEventListener('keydown', function (e) {
					if (e.key === 'Escape' && startModal.style.display === 'flex') {
						startModal.style.display = 'none';
					}
				});

				// ---------- Confirm Start Run ----------
				enterBtn.addEventListener('click', function () {
					const runName = runNameInput.value.trim();
					if (!runName) return;

					if (runNameDisplay) {
						runNameDisplay.textContent = '- ' + runName;
					}
					localStorage.setItem('currentRunName', runName);

					startDataCollection();
					if (window.startTemperatureReading) {
						window.startTemperatureReading();
					}
					if (window.setRunStartTime) {
						window.setRunStartTime();
					}

					startBtn.textContent = 'End Run';
					startBtn.classList.add('end-run-btn-active');
					startBtn.style.pointerEvents = 'auto';
					startBtn.style.cursor = 'pointer';

					startModal.style.display = 'none';
					runNameInput.value = '';
				});

				runNameInput.addEventListener('keydown', function (e) {
					if (e.key === 'Enter') {
						enterBtn.click();
					}
				});

				// ---------- End Run modal ----------
				if (endModal && closeEndBtn && cancelEndBtn && confirmEndBtn) {
					closeEndBtn.addEventListener('click', function () {
						endModal.style.display = 'none';
					});

					cancelEndBtn.addEventListener('click', function () {
						endModal.style.display = 'none';
					});

					endModal.addEventListener('click', function (e) {
						if (e.target === endModal) {
							endModal.style.display = 'none';
						}
					});

					confirmEndBtn.addEventListener('click', function () {
						const currentRunName = localStorage.getItem('currentRunName') || 'UnknownRun';

						stopDataCollectionAndExport(currentRunName);

						if (window.stopTemperatureReading) {
							window.stopTemperatureReading();
						}
						if (window.clearRunData) {
							window.clearRunData();
						}

						localStorage.removeItem('currentNotes');

						if (runNameDisplay) {
							runNameDisplay.textContent = '';
						}

						localStorage.removeItem('currentRunName');
						startBtn.textContent = 'Start Run';
						startBtn.classList.remove('end-run-btn-active');
						endModal.style.display = 'none';
					});

					document.addEventListener('keydown', function (e) {
						if (e.key === 'Escape' && endModal.style.display === 'flex') {
							endModal.style.display = 'none';
						}
					});
				}
			})();


			// Notes localStorage functionality
			(function () {
				const notesInput = document.getElementById('notes-input');
				if (!notesInput) return;

				const savedNotes = localStorage.getItem('currentNotes');
				if (savedNotes) {
					notesInput.value = savedNotes;
				}

				let saveTimeout;
				notesInput.addEventListener('input', function () {
					clearTimeout(saveTimeout);
					saveTimeout = setTimeout(function () {
						localStorage.setItem('currentNotes', notesInput.value);
					}, 500);
				});

				notesInput.addEventListener('blur', function () {
					clearTimeout(saveTimeout);
					localStorage.setItem('currentNotes', notesInput.value);
				});
			})();

			/* FOR LATER Live temperature readings from CSV file
			(function () {
				const CSV_FILE_PATH = 'data/temperature_readings.csv';

				let currentTemperatures = {
					temp1: '--', temp2: '--', temp3: '--',
					temp4: '--', temp5: '--', temp6: '--'
				};
				let currentHumidity = null;
				let temperatureReadingActive = false;

				function parseCSVData(csvText) {
					const lines = csvText.trim().split('\n');
					if (lines.length < 2) return null;

					const lastLine = lines[lines.length - 1];
					const values = lastLine.split(',');

					// Expected: timestamp,temp1,...,temp6,humidity,...
					if (values.length >= 8) {
						const sample = {
							timestamp: values[0],
							temp1: parseFloat(values[1]),
							temp2: parseFloat(values[2]),
							temp3: parseFloat(values[3]),
							temp4: parseFloat(values[4]),
							temp5: parseFloat(values[5]),
							temp6: parseFloat(values[6]),
							humidity: parseFloat(values[7])
						};
						return sample;
					}
					return null;
				}

				async function readCSVFile() {
					if (!temperatureReadingActive) return;

					try {
						const response = await fetch(CSV_FILE_PATH);
						if (!response.ok) {
							console.warn('Could not read CSV file:', response.statusText);
							return;
						}

						const csvText = await response.text();
						const sample = parseCSVData(csvText);

						if (sample) {
							currentTemperatures = {
								temp1: sample.temp1.toFixed(1),
								temp2: sample.temp2.toFixed(1),
								temp3: sample.temp3.toFixed(1),
								temp4: sample.temp4.toFixed(1),
								temp5: sample.temp5.toFixed(1),
								temp6: sample.temp6.toFixed(1)
							};
							currentHumidity = isNaN(sample.humidity) ? null : sample.humidity;

							updateTemperatureDisplay();

							// ðŸ”´ NEW: push data point to charts, if chart code is loaded
							if (window.pushSensorSample) {
								window.pushSensorSample({
									time: sample.timestamp ? new Date(sample.timestamp) : new Date(),
									temps: { ...currentTemperatures },
									humidity: currentHumidity
								});
							}
						}
					} catch (error) {
						console.warn('Error reading CSV file:', error);
						generateFallbackTemperatures();
					}
				}

				function generateFallbackTemperatures() {
					if (!temperatureReadingActive) return;

					for (let i = 1; i <= 6; i++) {
						const temp = (70 + Math.random() * 10).toFixed(1);
						currentTemperatures[`temp${i}`] = temp;
					}
					currentHumidity = 60 + Math.random() * 20;

					updateTemperatureDisplay();

					if (window.pushSensorSample) {
						window.pushSensorSample({
							time: new Date(),
							temps: { ...currentTemperatures },
							humidity: currentHumidity
						});
					}
				}

				function updateTemperatureDisplay() {
					for (let i = 1; i <= 6; i++) {
						const tempElement = document.getElementById(`temp-${i}`);
						if (tempElement) {
							tempElement.textContent = currentTemperatures[`temp${i}`] || '--';
						}
					}
				}

				function startTemperatureReading() {
					temperatureReadingActive = true;
					readCSVFile();
				}

				function stopTemperatureReading() {
					temperatureReadingActive = false;
					currentTemperatures = {
						temp1: '--', temp2: '--', temp3: '--',
						temp4: '--', temp5: '--', temp6: '--'
					};
					currentHumidity = null;
					updateTemperatureDisplay();
				}

				function getCurrentTemperatures() {
					return currentTemperatures;
				}

				window.getCurrentTemperatures = getCurrentTemperatures;
				window.startTemperatureReading = startTemperatureReading;
				window.stopTemperatureReading = stopTemperatureReading;

				const savedRunName = localStorage.getItem('currentRunName');
				if (savedRunName) {
					temperatureReadingActive = true;
				}

				setInterval(readCSVFile, 5000);
			})();
			*/

			// Simulated live temperature readings (20â€“50 Â°C) + humidity
			(function () {
				// Store the latest temperature readings
				let currentTemperatures = {
					temp1: '--', temp2: '--', temp3: '--',
					temp4: '--', temp5: '--', temp6: '--'
				};

				let currentHumidity = null;
				let temperatureReadingActive = false;
				let simIntervalId = null;

				function updateTemperatureDisplay() {
					for (let i = 1; i <= 6; i++) {
						const tempElement = document.getElementById(`temp-${i}`);
						if (tempElement) {
							tempElement.textContent = currentTemperatures[`temp${i}`] || '--';
						}
					}
				}

				// Generate random temperatures between 20â€“50 Â°C and random humidity
				function generateRandomSample() {
					if (!temperatureReadingActive) return;

					for (let i = 1; i <= 6; i++) {
						const tempC = 20 + Math.random() * 30; // 20â€“50 Â°C
						currentTemperatures[`temp${i}`] = tempC.toFixed(1);
					}

					currentHumidity = (40 + Math.random() * 40).toFixed(1); // 40â€“80 % RH

					updateTemperatureDisplay();

					// Push to charts if chart logic is present
					if (window.pushSensorSample) {
						window.pushSensorSample({
							time: new Date(),
							temps: { ...currentTemperatures },
							humidity: currentHumidity
						});
					}
				}

				function startTemperatureReading() {
					if (temperatureReadingActive) return;
					temperatureReadingActive = true;

					// Immediate first sample
					generateRandomSample();

					// Then update every 5 seconds
					simIntervalId = setInterval(generateRandomSample, 5000);
				}

				function stopTemperatureReading() {
					temperatureReadingActive = false;
					if (simIntervalId) {
						clearInterval(simIntervalId);
						simIntervalId = null;
					}

					currentTemperatures = {
						temp1: '--', temp2: '--', temp3: '--',
						temp4: '--', temp5: '--', temp6: '--'
					};
					currentHumidity = null;
					updateTemperatureDisplay();
				}

				function getCurrentTemperatures() {
					return currentTemperatures;
				}

				// Expose globally for the rest of your code
				window.getCurrentTemperatures = getCurrentTemperatures;
				window.startTemperatureReading = startTemperatureReading;
				window.stopTemperatureReading = stopTemperatureReading;

				// If you want it to auto-run when a run name exists, you can uncomment:
				// const savedRunName = localStorage.getItem('currentRunName');
				// if (savedRunName) {
				//     startTemperatureReading();
				// }
			})();

			// Live-updating charts for temperature and humidity
			(function () {
				const tempCanvas = document.getElementById('temp-chart');
				const humCanvas = document.getElementById('humidity-chart');

				if (!tempCanvas || !humCanvas || !window.Chart) return;

				const tempCtx = tempCanvas.getContext('2d');
				const humCtx = humCanvas.getContext('2d');

				const maxPoints = 60; // keep last 60 samples (~5 min if 5s interval)
				const labels = [];
				const humidityData = [];

				const tempSeries = {
					temp1: [],
					temp2: [],
					temp3: [],
					temp4: [],
					temp5: [],
					temp6: []
				};

				const tempChart = new Chart(tempCtx, {
					type: 'line',
					data: {
						labels,
						datasets: [
							{ label: 'Temp 1', data: tempSeries.temp1, borderWidth: 1, pointRadius: 0 },
							{ label: 'Temp 2', data: tempSeries.temp2, borderWidth: 1, pointRadius: 0 },
							{ label: 'Temp 3', data: tempSeries.temp3, borderWidth: 1, pointRadius: 0 },
							{ label: 'Temp 4', data: tempSeries.temp4, borderWidth: 1, pointRadius: 0 },
							{ label: 'Temp 5', data: tempSeries.temp5, borderWidth: 1, pointRadius: 0 },
							{ label: 'Temp 6', data: tempSeries.temp6, borderWidth: 1, pointRadius: 0 }
						]
					},
					options: {
						animation: false,
						responsive: true,
						maintainAspectRatio: false,
						scales: {
							x: {
								ticks: { autoSkip: true, maxTicksLimit: 6 }
							},
							y: {
								title: { display: true, text: 'Temperature (Â°F)' }
							}
						},
						plugins: {
							legend: { position: 'bottom' }
						}
					}
				});

				const humChart = new Chart(humCtx, {
					type: 'line',
					data: {
						labels,
						datasets: [
							{ label: 'Humidity', data: humidityData, borderWidth: 1, pointRadius: 0 }
						]
					},
					options: {
						animation: false,
						responsive: true,
						maintainAspectRatio: false,
						scales: {
							x: {
								ticks: { autoSkip: true, maxTicksLimit: 6 }
							},
							y: {
								title: { display: true, text: 'Humidity (%)' }
							}
						},
						plugins: {
							legend: { display: false }
						}
					}
				});

				// This gets called from the CSV reader IIFE
				window.pushSensorSample = function (sample) {
					const t = sample.time instanceof Date ? sample.time : new Date(sample.time);
					const label = t.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

					labels.push(label);
					for (let i = 1; i <= 6; i++) {
						const key = `temp${i}`;
						const val = parseFloat(sample.temps[key]);
						tempSeries[key].push(isNaN(val) ? null : val);
					}

					const humVal = parseFloat(sample.humidity);
					humidityData.push(isNaN(humVal) ? null : humVal);

					// keep array lengths bounded
					if (labels.length > maxPoints) {
						labels.shift();
						Object.values(tempSeries).forEach(arr => arr.shift());
						humidityData.shift();
					}

					tempChart.update('none');
					humChart.update('none');
				};
			})();


			// Target temperature CSV upload and deviation detection
			(function () {
				let targetTemperatures = [];
				let runStartTime = null;

				function parseTargetCSV(csvText) {
					const lines = csvText.trim().split('\n');
					if (lines.length < 2) return [];

					const targets = [];
					for (let i = 1; i < lines.length; i++) {
						const values = lines[i].split(',');
						if (values.length >= 7) {
							targets.push({
								time: parseFloat(values[0]),
								temp1: parseFloat(values[1]),
								temp2: parseFloat(values[2]),
								temp3: parseFloat(values[3]),
								temp4: parseFloat(values[4]),
								temp5: parseFloat(values[5]),
								temp6: parseFloat(values[6])
							});
						}
					}
					return targets.sort((a, b) => a.time - b.time);
				}

				function getCurrentTargets() {
					if (!runStartTime || targetTemperatures.length === 0) return null;

					const elapsedMinutes = (Date.now() - runStartTime) / (1000 * 60);
					let currentTarget = null;

					for (let i = 0; i < targetTemperatures.length; i++) {
						if (targetTemperatures[i].time <= elapsedMinutes) {
							currentTarget = targetTemperatures[i];
						} else {
							break;
						}
					}
					return currentTarget;
				}

				function applyDeviationColors() {
					const currentTargets = getCurrentTargets();
					const currentTemps = window.getCurrentTemperatures ? window.getCurrentTemperatures() : null;

					for (let i = 1; i <= 6; i++) {
						const tempElement = document.getElementById(`temp-${i}`);
						if (!tempElement) continue;

						tempElement.classList.remove(
							'temp-good',
							'temp-warning',
							'temp-danger',
							'temp-too-hot',
							'temp-too-cold'
						);

						if (currentTargets && currentTemps && currentTemps[`temp${i}`] !== '--') {
							const actualTemp = parseFloat(currentTemps[`temp${i}`]);
							const targetTemp = currentTargets[`temp${i}`];

							if (!isNaN(actualTemp) && !isNaN(targetTemp)) {
								const deviation = actualTemp - targetTemp;

								if (deviation >= 5.0) {
									tempElement.classList.add('temp-too-hot');
								} else if (deviation <= -5.0) {
									tempElement.classList.add('temp-too-cold');
								} else {
									tempElement.classList.add('temp-good');
								}
							}
						}
					}
				}

				function setRunStartTime() {
					runStartTime = Date.now();
				}

				function clearRunData() {
					runStartTime = null;
					for (let i = 1; i <= 6; i++) {
						const tempElement = document.getElementById(`temp-${i}`);
						if (tempElement) {
							tempElement.classList.remove(
								'temp-good',
								'temp-warning',
								'temp-danger',
								'temp-too-hot',
								'temp-too-cold'
							);
						}
					}
				}

				function setupFileUploadHandler() {
					const fileInput = document.getElementById('target-csv-upload');
					const uploadStatus = document.getElementById('upload-status');

					if (fileInput && !fileInput.hasAttribute('data-handler-added')) {
						fileInput.setAttribute('data-handler-added', 'true');
						fileInput.addEventListener('change', function (e) {
							const file = e.target.files[0];
							if (!file) {
								if (uploadStatus) uploadStatus.textContent = '';
								return;
							}

							const reader = new FileReader();
							reader.onload = function (event) {
								try {
									targetTemperatures = parseTargetCSV(event.target.result);
									if (targetTemperatures.length > 0) {
										if (uploadStatus) {
											uploadStatus.textContent = `âœ“ Loaded ${targetTemperatures.length} target points`;
											uploadStatus.style.color = '#28a745';
										}
									} else {
										if (uploadStatus) {
											uploadStatus.textContent = 'âš  No valid data found';
											uploadStatus.style.color = '#ffc107';
										}
									}
								} catch (error) {
									if (uploadStatus) {
										uploadStatus.textContent = 'âœ— Error parsing CSV';
										uploadStatus.style.color = '#dc3545';
									}
								}
							};
							reader.readAsText(file);
						});
					}
				}

				window.setRunStartTime = setRunStartTime;
				window.clearRunData = clearRunData;
				window.applyDeviationColors = applyDeviationColors;
				window.setupFileUploadHandler = setupFileUploadHandler;

				setInterval(applyDeviationColors, 5000);
			})();


			// Easter egg: Pong game when clicking the logo (with more random CPU + forgiving collisions)
			(function () {
				const logo = document.getElementById('sake-logo-egg');
				const pongModal = document.getElementById('pong-modal');
				const pongClose = document.getElementById('pong-close-btn');
				const canvas = document.getElementById('pong-canvas');

				if (!logo || !pongModal || !canvas) return;

				const ctx = canvas.getContext('2d');

				let animationId = null;
				let ball, paddleLeft, paddleRight;
				let upPressed = false;
				let downPressed = false;

				const HITBOX_PADDING = 3;
				const PLAYER_SPEED = 4;
				const AI_MAX_SPEED = 3;
				const AI_NOISE_RANGE = 25;

				function resetGame() {
					ball = {
						x: canvas.width / 2,
						y: canvas.height / 2,
						vx: 3 * (Math.random() > 0.5 ? 1 : -1),
						vy: (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1),
						r: 6
					};
					paddleLeft = {
						x: 10,
						y: canvas.height / 2 - 25,
						w: 8,
						h: 50
					};
					paddleRight = {
						x: canvas.width - 18,
						y: canvas.height / 2 - 25,
						w: 8,
						h: 50
					};
				}

				function draw() {
					ctx.fillStyle = '#000';
					ctx.fillRect(0, 0, canvas.width, canvas.height);

					ctx.strokeStyle = '#444';
					ctx.setLineDash([5, 5]);
					ctx.beginPath();
					ctx.moveTo(canvas.width / 2, 0);
					ctx.lineTo(canvas.width / 2, canvas.height);
					ctx.stroke();
					ctx.setLineDash([]);

					ctx.fillStyle = '#fff';
					ctx.fillRect(paddleLeft.x, paddleLeft.y, paddleLeft.w, paddleLeft.h);
					ctx.fillRect(paddleRight.x, paddleRight.y, paddleRight.w, paddleRight.h);

					ctx.beginPath();
					ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
					ctx.fill();
				}

				function update() {
					// player paddle
					if (upPressed) paddleLeft.y -= PLAYER_SPEED;
					if (downPressed) paddleLeft.y += PLAYER_SPEED;
					paddleLeft.y = Math.max(0, Math.min(canvas.height - paddleLeft.h, paddleLeft.y));

					// CPU paddle
					let aiTargetY;
					if (ball.x > canvas.width * 0.4) {
						const noise = (Math.random() - 0.5) * AI_NOISE_RANGE;
						aiTargetY = ball.y + noise - paddleRight.h / 2;
					} else {
						aiTargetY = canvas.height / 2 - paddleRight.h / 2;
					}

					if (aiTargetY > paddleRight.y) {
						paddleRight.y = Math.min(paddleRight.y + AI_MAX_SPEED, aiTargetY);
					} else {
						paddleRight.y = Math.max(paddleRight.y - AI_MAX_SPEED, aiTargetY);
					}
					paddleRight.y = Math.max(0, Math.min(canvas.height - paddleRight.h, paddleRight.y));

					// ball motion
					ball.x += ball.vx;
					ball.y += ball.vy;

					// top/bottom bounce
					if (ball.y - ball.r < 0) {
						ball.y = ball.r;
						ball.vy *= -1;
					} else if (ball.y + ball.r > canvas.height) {
						ball.y = canvas.height - ball.r;
						ball.vy *= -1;
					}

					// left paddle collision (forgiving hitbox)
					if (
						ball.x - ball.r <= paddleLeft.x + paddleLeft.w + HITBOX_PADDING &&
						ball.x - ball.r >= paddleLeft.x - HITBOX_PADDING &&
						ball.y >= paddleLeft.y - HITBOX_PADDING &&
						ball.y <= paddleLeft.y + paddleLeft.h + HITBOX_PADDING
					) {
						ball.x = paddleLeft.x + paddleLeft.w + ball.r + HITBOX_PADDING;
						ball.vx = Math.abs(ball.vx);

						const offset = (ball.y - (paddleLeft.y + paddleLeft.h / 2)) / (paddleLeft.h / 2);
						ball.vy += offset * 1.5;
					}

					// right paddle collision (CPU)
					if (
						ball.x + ball.r >= paddleRight.x - HITBOX_PADDING &&
						ball.x + ball.r <= paddleRight.x + paddleRight.w + HITBOX_PADDING &&
						ball.y >= paddleRight.y - HITBOX_PADDING &&
						ball.y <= paddleRight.y + paddleRight.h + HITBOX_PADDING
					) {
						ball.x = paddleRight.x - ball.r - HITBOX_PADDING;
						ball.vx = -Math.abs(ball.vx);

						const offset = (ball.y - (paddleRight.y + paddleRight.h / 2)) / (paddleRight.h / 2);
						ball.vy += offset * 1.5;
					}

					// reset if out of bounds
					if (ball.x < -30 || ball.x > canvas.width + 30) {
						resetGame();
					}
				}

				function loop() {
					update();
					draw();
					animationId = requestAnimationFrame(loop);
				}

				function keyDownHandler(e) {
					if (e.key === 'ArrowUp') {
						upPressed = true;
					} else if (e.key === 'ArrowDown') {
						downPressed = true;
					} else if (e.key === 'Escape') {
						closePong();
					}
				}

				function keyUpHandler(e) {
					if (e.key === 'ArrowUp') {
						upPressed = false;
					} else if (e.key === 'ArrowDown') {
						downPressed = false;
					}
				}

				function openPong() {
					resetGame();
					pongModal.style.display = 'flex';
					loop();
					document.addEventListener('keydown', keyDownHandler);
					document.addEventListener('keyup', keyUpHandler);
				}

				function closePong() {
					pongModal.style.display = 'none';
					if (animationId) cancelAnimationFrame(animationId);
					animationId = null;
					document.removeEventListener('keydown', keyDownHandler);
					document.removeEventListener('keyup', keyUpHandler);
				}

				logo.addEventListener('click', openPong);

				if (pongClose) {
					pongClose.addEventListener('click', closePong);
				}
				pongModal.addEventListener('click', function (e) {
					if (e.target === pongModal) {
						closePong();
					}
				});
			})();
		</script>


	</div> <!-- end page-wrapper -->
</body>

</html>